\documentclass[14pt]{extarticle}
\usepackage{xltxtra}
\usepackage{polyglossia}
\setmainlanguage{russian}
\setotherlanguage{english}
\newfontfamily{\cyrillicfont}{Times New Roman}
\setmainfont{Times New Roman}
\setromanfont{Times New Roman}
\setsansfont{Arial}
\setmonofont{Consolas}
\usepackage{array, makecell, footnote, setspace, anyfontsize, multicol, amsmath, graphicx}
\usepackage[paperwidth=210mm, paperheight=297mm, voffset=-5.5mm, hoffset=4.5mm, textheight=257mm, textwidth=165mm]{geometry}

\begin{document}
\begin{enumerate}
	\item Что послужило толчком к созданию парадигмы ООП?

	      Толчком к созданию парадигмы послужил кризис программного обеспечения (высокая сложность программ в промышленности, координирование команды разработчиков, необходимость в сопровождении программы), трудность в достижении слабой связанности в структурной декомпозиции, проблема общего глобального пространства имён.

	\item Экскурс в историю: в каком языке были разработаны основные принципы ООП? Дайте краткий обзор этого языка.

	      Первым объектно-ориентированным языком был язык программирования Симула, который был создан в компьютерном центре в Норвегии. Язык предназначался для моделирования ситуаций реального мира. Особенностью Simula было то, что программа, написанная на языке, была организована по объектам программирования. Объекты имели инструкции, называемые методами, и данные, которые назывались переменными; методы и данные определяли поведение объекта. В процессе моделирования объект вел себя согласно своему стандартному поведению и, в случае необходимости, изменял данные для отражения влияния назначенного ему действия.

	\item Подробно опишите показатели качества декомпозиции программы

	      Показателями качества декомпозиции программы являются:

	      Сцепление внутри компонента это показатель, характеризующий степень взаимосвязей отдельных его частей (если внутри компонента решаются 2 подзадачи, которые легко можно разделить, то компонент обладает слабым, плохим сцеплением) и связанность между компонентами (это показатель описывающий интерфейс между компонентом клиентом и компонентом сервером). Общее число входов и выходов сервера - есть мера связанности. Чем меньше связанность между двумя компонентами, тем проще поменять и отслеживать в будущем их взаимодействия, а так как в больших проектах эти компоненты часто разрабатывается разными людьми, то очень важно уменьшать связанность между компонентами.

	\item Назовите несколько отличий языков C и С++.
	      \begin{itemize}
		      \item В C++ появились классы и объекты.
		      \item В С символьная константа автоматически повышается до целого числа. В С++ это не так.
		      \item В С можно вызвать функцию main() из программы, хотя это и нетипично. В С++ это недопустимо.
		      \item Разные стандартные расширения файлов, .c для С, и .cpp С++.
	      \end{itemize}
	\item Подробно опишите идентификаторы (где начало и конец области действия, какова видимость, каково время жизни), описанные в блоке, файле, функции, прототипе функции, классе и поименованной области.

	      В блоке:
	      \begin{itemize}
		      \item Начало области действия идентификатора, когда происходит объявление в блоке
		      \item Конец области действия идентификатора, когда заканчивается блок
		      \item Видимость только в блоке
		      \item Время жизни, пока работает программа через блок.
	      \end{itemize}
	      В файле:
	      \begin{itemize}
		      \item Начало области действия идентификатора при объявлении в функциии
		      \item Конец области действия идентификатора, когда заканчивается программа
		      \item Видимость во всем, но не в тех функциях, куда не передаётся
		      \item Время жизни , пока работает программа
	      \end{itemize}
	      В функции:
	      \begin{itemize}
		      \item Начало области действия идентификатора также при объявлении
		      \item Конец области действия идентификатора, когда заканчивается функция
		      \item Виден после того, как объявили в программе
		      \item Время жизни, пока исполняется, то есть, когда вызывают
	      \end{itemize}
	      В прототипе функции:
	      \begin{itemize}
		      \item Начало области действия идентификатора также при объявлении
		      \item Конец области действия идентификатора, когда заканчивается функция
		      \item Виден после того, как объявили в программе
		      \item Время жизни, пока исполняется, то есть, когда вызывают
		      \item (используется для обозначения существования для компилятора до тех пор, пока еще не определили функцию)
	      \end{itemize}
	      В классе:
	      \begin{itemize}
		      \item Начало области действия идентификатора, когда создается объект, в котором используется
		      \item Конец области действия идентификатора, при удалении объекта
		      \item Виден везде, при устловии, что создан в основном теле программы
		      \item Время жизни, пока объект продолжает существование в программе
	      \end{itemize}
	      В поименованной области:
	      \begin{itemize}
		      \item Начало области действия идентификатора, когда происходит объявление
		      \item Конец области действия идентификатора , когда заканчивается программа
		      \item Виден везде после объявления
		      \item Время жизни до конца программы
	      \end{itemize}
	\item Чем отличаются заголовочные файлы stdio.h и cstdio?

	      stdio.h используется в С, а cstdio в С++, в современных библиотеках имеются более безопасные аналоги «классических» функций.

	\item В чём структурный подход к программированию уступает объектно-ориентированному подходу?
	      \begin{itemize}
		      \item повышение степени абстракции программы
		      \item ослабление связанности между компонентами программы
		      \item повышение надёжности программ
		      \item облегчение модификации программы
		      \item свойства не описываются повторно
	      \end{itemize}
\end{enumerate}
\end{document}
